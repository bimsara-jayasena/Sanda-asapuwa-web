{"ast":null,"code":"var CAN_USE_DOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n// Adapted from Modernizr\n// https://github.com/Modernizr/Modernizr/blob/acb3f0d9/feature-detects/dom/passiveeventlisteners.js#L26-L37\nfunction testPassiveEventListeners() {\n  if (!CAN_USE_DOM) {\n    return false;\n  }\n  if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n    return false;\n  }\n  var supportsPassiveOption = false;\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get: function () {\n        function get() {\n          supportsPassiveOption = true;\n        }\n        return get;\n      }()\n    });\n    var noop = function noop() {};\n    window.addEventListener('testPassiveEventSupport', noop, opts);\n    window.removeEventListener('testPassiveEventSupport', noop, opts);\n  } catch (e) {\n    // do nothing\n  }\n  return supportsPassiveOption;\n}\nvar memoized = void 0;\nfunction canUsePassiveEventListeners() {\n  if (memoized === undefined) {\n    memoized = testPassiveEventListeners();\n  }\n  return memoized;\n}\nfunction normalizeEventOptions(eventOptions) {\n  if (!eventOptions) {\n    return undefined;\n  }\n  if (!canUsePassiveEventListeners()) {\n    // If the browser does not support the passive option, then it is expecting\n    // a boolean for the options argument to specify whether it should use\n    // capture or not. In more modern browsers, this is passed via the `capture`\n    // option, so let's just hoist that value up.\n    return !!eventOptions.capture;\n  }\n  return eventOptions;\n}\n\n/* eslint-disable no-bitwise */\n\n/**\n * Generate a unique key for any set of event options\n */\nfunction eventOptionsKey(normalizedEventOptions) {\n  if (!normalizedEventOptions) {\n    return 0;\n  }\n\n  // If the browser does not support passive event listeners, the normalized\n  // event options will be a boolean.\n  if (normalizedEventOptions === true) {\n    return 100;\n  }\n\n  // At this point, the browser supports passive event listeners, so we expect\n  // the event options to be an object with possible properties of capture,\n  // passive, and once.\n  //\n  // We want to consistently return the same value, regardless of the order of\n  // these properties, so let's use binary maths to assign each property to a\n  // bit, and then add those together (with an offset to account for the\n  // booleans at the beginning of this function).\n  var capture = normalizedEventOptions.capture << 0;\n  var passive = normalizedEventOptions.passive << 1;\n  var once = normalizedEventOptions.once << 2;\n  return capture + passive + once;\n}\nfunction ensureCanMutateNextEventHandlers(eventHandlers) {\n  if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n    // eslint-disable-next-line no-param-reassign\n    eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n  }\n}\nfunction TargetEventHandlers(target) {\n  this.target = target;\n  this.events = {};\n}\nTargetEventHandlers.prototype.getEventHandlers = function () {\n  function getEventHandlers(eventName, options) {\n    var key = String(eventName) + ' ' + String(eventOptionsKey(options));\n    if (!this.events[key]) {\n      this.events[key] = {\n        handlers: [],\n        handleEvent: undefined\n      };\n      this.events[key].nextHandlers = this.events[key].handlers;\n    }\n    return this.events[key];\n  }\n  return getEventHandlers;\n}();\nTargetEventHandlers.prototype.handleEvent = function () {\n  function handleEvent(eventName, options, event) {\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    eventHandlers.handlers = eventHandlers.nextHandlers;\n    eventHandlers.handlers.forEach(function (handler) {\n      if (handler) {\n        // We need to check for presence here because a handler function may\n        // cause later handlers to get removed. This can happen if you for\n        // instance have a waypoint that unmounts another waypoint as part of an\n        // onEnter/onLeave handler.\n        handler(event);\n      }\n    });\n  }\n  return handleEvent;\n}();\nTargetEventHandlers.prototype.add = function () {\n  function add(eventName, listener, options) {\n    var _this = this;\n\n    // options has already been normalized at this point.\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    ensureCanMutateNextEventHandlers(eventHandlers);\n    if (eventHandlers.nextHandlers.length === 0) {\n      eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n      this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n    }\n    eventHandlers.nextHandlers.push(listener);\n    var isSubscribed = true;\n    var unsubscribe = function () {\n      function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n        isSubscribed = false;\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        var index = eventHandlers.nextHandlers.indexOf(listener);\n        eventHandlers.nextHandlers.splice(index, 1);\n        if (eventHandlers.nextHandlers.length === 0) {\n          // All event handlers have been removed, so we want to remove the event\n          // listener from the target node.\n\n          if (_this.target) {\n            // There can be a race condition where the target may no longer exist\n            // when this function is called, e.g. when a React component is\n            // unmounting. Guarding against this prevents the following error:\n            //\n            //   Cannot read property 'removeEventListener' of undefined\n            _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n          }\n          eventHandlers.handleEvent = undefined;\n        }\n      }\n      return unsubscribe;\n    }();\n    return unsubscribe;\n  }\n  return add;\n}();\nvar EVENT_HANDLERS_KEY = '__consolidated_events_handlers__';\n\n// eslint-disable-next-line import/prefer-default-export\nfunction addEventListener(target, eventName, listener, options) {\n  if (!target[EVENT_HANDLERS_KEY]) {\n    // eslint-disable-next-line no-param-reassign\n    target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n  }\n  var normalizedEventOptions = normalizeEventOptions(options);\n  return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n}\nexport { addEventListener };","map":{"version":3,"names":["CAN_USE_DOM","window","document","createElement","testPassiveEventListeners","addEventListener","removeEventListener","Object","defineProperty","supportsPassiveOption","opts","get","noop","e","memoized","canUsePassiveEventListeners","undefined","normalizeEventOptions","eventOptions","capture","eventOptionsKey","normalizedEventOptions","passive","once","ensureCanMutateNextEventHandlers","eventHandlers","handlers","nextHandlers","slice","TargetEventHandlers","target","events","prototype","getEventHandlers","eventName","options","key","String","handleEvent","event","forEach","handler","add","listener","_this","length","bind","push","isSubscribed","unsubscribe","index","indexOf","splice","EVENT_HANDLERS_KEY"],"sources":["D:/Document/Education/Self_study/practicals/SandaAsapuwa/WEB/client/my-app/node_modules/consolidated-events/lib/index.esm.js"],"sourcesContent":["var CAN_USE_DOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n// Adapted from Modernizr\n// https://github.com/Modernizr/Modernizr/blob/acb3f0d9/feature-detects/dom/passiveeventlisteners.js#L26-L37\nfunction testPassiveEventListeners() {\n  if (!CAN_USE_DOM) {\n    return false;\n  }\n\n  if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n    return false;\n  }\n\n  var supportsPassiveOption = false;\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get: function () {\n        function get() {\n          supportsPassiveOption = true;\n        }\n\n        return get;\n      }()\n    });\n    var noop = function noop() {};\n    window.addEventListener('testPassiveEventSupport', noop, opts);\n    window.removeEventListener('testPassiveEventSupport', noop, opts);\n  } catch (e) {\n    // do nothing\n  }\n\n  return supportsPassiveOption;\n}\n\nvar memoized = void 0;\n\nfunction canUsePassiveEventListeners() {\n  if (memoized === undefined) {\n    memoized = testPassiveEventListeners();\n  }\n  return memoized;\n}\n\nfunction normalizeEventOptions(eventOptions) {\n  if (!eventOptions) {\n    return undefined;\n  }\n\n  if (!canUsePassiveEventListeners()) {\n    // If the browser does not support the passive option, then it is expecting\n    // a boolean for the options argument to specify whether it should use\n    // capture or not. In more modern browsers, this is passed via the `capture`\n    // option, so let's just hoist that value up.\n    return !!eventOptions.capture;\n  }\n\n  return eventOptions;\n}\n\n/* eslint-disable no-bitwise */\n\n/**\n * Generate a unique key for any set of event options\n */\nfunction eventOptionsKey(normalizedEventOptions) {\n  if (!normalizedEventOptions) {\n    return 0;\n  }\n\n  // If the browser does not support passive event listeners, the normalized\n  // event options will be a boolean.\n  if (normalizedEventOptions === true) {\n    return 100;\n  }\n\n  // At this point, the browser supports passive event listeners, so we expect\n  // the event options to be an object with possible properties of capture,\n  // passive, and once.\n  //\n  // We want to consistently return the same value, regardless of the order of\n  // these properties, so let's use binary maths to assign each property to a\n  // bit, and then add those together (with an offset to account for the\n  // booleans at the beginning of this function).\n  var capture = normalizedEventOptions.capture << 0;\n  var passive = normalizedEventOptions.passive << 1;\n  var once = normalizedEventOptions.once << 2;\n  return capture + passive + once;\n}\n\nfunction ensureCanMutateNextEventHandlers(eventHandlers) {\n  if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n    // eslint-disable-next-line no-param-reassign\n    eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n  }\n}\n\nfunction TargetEventHandlers(target) {\n  this.target = target;\n  this.events = {};\n}\n\nTargetEventHandlers.prototype.getEventHandlers = function () {\n  function getEventHandlers(eventName, options) {\n    var key = String(eventName) + ' ' + String(eventOptionsKey(options));\n\n    if (!this.events[key]) {\n      this.events[key] = {\n        handlers: [],\n        handleEvent: undefined\n      };\n      this.events[key].nextHandlers = this.events[key].handlers;\n    }\n\n    return this.events[key];\n  }\n\n  return getEventHandlers;\n}();\n\nTargetEventHandlers.prototype.handleEvent = function () {\n  function handleEvent(eventName, options, event) {\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    eventHandlers.handlers = eventHandlers.nextHandlers;\n    eventHandlers.handlers.forEach(function (handler) {\n      if (handler) {\n        // We need to check for presence here because a handler function may\n        // cause later handlers to get removed. This can happen if you for\n        // instance have a waypoint that unmounts another waypoint as part of an\n        // onEnter/onLeave handler.\n        handler(event);\n      }\n    });\n  }\n\n  return handleEvent;\n}();\n\nTargetEventHandlers.prototype.add = function () {\n  function add(eventName, listener, options) {\n    var _this = this;\n\n    // options has already been normalized at this point.\n    var eventHandlers = this.getEventHandlers(eventName, options);\n\n    ensureCanMutateNextEventHandlers(eventHandlers);\n\n    if (eventHandlers.nextHandlers.length === 0) {\n      eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n\n      this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n    }\n\n    eventHandlers.nextHandlers.push(listener);\n\n    var isSubscribed = true;\n    var unsubscribe = function () {\n      function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n\n        isSubscribed = false;\n\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        var index = eventHandlers.nextHandlers.indexOf(listener);\n        eventHandlers.nextHandlers.splice(index, 1);\n\n        if (eventHandlers.nextHandlers.length === 0) {\n          // All event handlers have been removed, so we want to remove the event\n          // listener from the target node.\n\n          if (_this.target) {\n            // There can be a race condition where the target may no longer exist\n            // when this function is called, e.g. when a React component is\n            // unmounting. Guarding against this prevents the following error:\n            //\n            //   Cannot read property 'removeEventListener' of undefined\n            _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n          }\n\n          eventHandlers.handleEvent = undefined;\n        }\n      }\n\n      return unsubscribe;\n    }();\n    return unsubscribe;\n  }\n\n  return add;\n}();\n\nvar EVENT_HANDLERS_KEY = '__consolidated_events_handlers__';\n\n// eslint-disable-next-line import/prefer-default-export\nfunction addEventListener(target, eventName, listener, options) {\n  if (!target[EVENT_HANDLERS_KEY]) {\n    // eslint-disable-next-line no-param-reassign\n    target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n  }\n  var normalizedEventOptions = normalizeEventOptions(options);\n  return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n}\n\nexport { addEventListener };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}